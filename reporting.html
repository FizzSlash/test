<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Marketing Analytics Dashboard</title>
  <!-- Include React and ReactDOM -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <!-- Include Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Include Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Include Lodash -->
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <!-- Include Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <style>
    body {
      background-color: rgba(20, 19, 28, 0.7);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    /* Container styling with white stroke */
    .dashboard-container {
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.07);
      background-color: rgba(20, 19, 28, 0.4);
      backdrop-filter: blur(12px);
      border-radius: 10px;
      overflow: hidden;
    }
    
    .dashboard-widget {
      background-color: rgba(36, 35, 49, 0.4);
      border-left: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }
    
    .dashboard-widget:hover {
      background-color: rgba(36, 35, 49, 0.5);
      border-left: 2px solid rgba(255, 255, 255, 0.5);
    }
    
    /* Status badge styling */
    .status-badge {
      background-color: rgba(255, 255, 255, 0.15) !important;
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      color: rgb(255, 255, 255) !important;
      font-weight: 500;
      padding: 2px 8px;
      border-radius: 4px;
      white-space: normal;
      display: inline-block;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Header styling for consistency */
    .header-container {
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      background-color: rgba(0, 0, 0, 0.2);
    }
    
    /* Card styling */
    .dashboard-card {
      border: 1px solid rgba(255, 255, 255, 0.15);
      background-color: rgba(36, 35, 49, 0.4);
      border-radius: 10px;
      overflow: hidden;
      transition: all 0.2s ease;
    }
    
    .dashboard-card:hover {
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
    }
    
    /* Button styling */
    .dashboard-button {
      background-color: transparent;
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      transition: all 0.2s ease;
    }
    
    .dashboard-button:hover {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    /* Table styling */
    .dashboard-table th,
    .dashboard-table td {
      padding: 0.75rem 1rem;
      text-align: left;
    }
    
    .dashboard-table th {
      background-color: rgba(0, 0, 0, 0.2);
      font-weight: 500;
      cursor: pointer;
    }
    
    .dashboard-table tr {
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .dashboard-table tr:hover {
      background-color: rgba(255, 255, 255, 0.08);
    }
    
    /* Metric card styling */
    .metric-card {
      background-color: rgba(36, 35, 49, 0.6);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 1rem;
      transition: all 0.2s ease;
    }
    
    .metric-card:hover {
      border-color: rgba(255, 255, 255, 0.3);
      background-color: rgba(36, 35, 49, 0.7);
    }
    
    .metric-value {
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    .metric-label {
      font-size: 0.875rem;
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Chart containers */
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    /* Loading state */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top: 4px solid rgba(255, 255, 255, 0.8);
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Error state */
    .error-container {
      background-color: rgba(220, 38, 38, 0.2);
      border: 1px solid rgba(220, 38, 38, 0.5);
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
    }
    
    /* Revenue bar chart */
    .revenue-bar {
      height: 24px;
      background: linear-gradient(to right, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4));
      border-radius: 4px;
      margin: 8px 0;
      position: relative;
      overflow: hidden;
    }
    
    .revenue-bar-label {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-weight: 500;
      color: rgba(20, 19, 28, 0.9);
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    .revenue-bar-value {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-weight: 600;
      color: rgba(20, 19, 28, 0.9);
    }
    
    /* Positive/negative indicators */
    .positive-change {
      color: #10B981;
    }
    
    .negative-change {
      color: #EF4444;
    }
    
    /* Flow group headers */
    .flow-group-header {
      background-color: rgba(255, 255, 255, 0.08);
      padding: 0.5rem 1rem;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
      border-left: 3px solid rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body class="bg-transparent">
  <div id="root" class="min-h-screen py-8"></div>

  <script type="text/babel">
    // Import React hooks
    const { useState, useEffect, useRef } = React;
    
    // Utility functions
    const formatCurrency = (value) => {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2
      }).format(value);
    };
    
    const formatPercentage = (value) => {
      // Convert to actual percentage display (e.g., 55.55% instead of 0.5%)
      return new Intl.NumberFormat('en-US', {
        style: 'percent',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }).format(value / 100);
    };
    
    const formatNumber = (value) => {
      return new Intl.NumberFormat('en-US').format(value);
    };
    
    const formatDate = (dateStr) => {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric'
      });
    };
    
    // Helper for sorting data
    const sortData = (data, sortField, sortDirection) => {
      return [...data].sort((a, b) => {
        const valueA = a[sortField];
        const valueB = b[sortField];
        
        // Handle numeric values
        if (!isNaN(valueA) && !isNaN(valueB)) {
          return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
        }
        
        // Handle date values
        if (valueA instanceof Date && valueB instanceof Date) {
          return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
        }
        
        // Handle string values
        const stringA = String(valueA).toLowerCase();
        const stringB = String(valueB).toLowerCase();
        return sortDirection === 'asc' 
          ? stringA.localeCompare(stringB) 
          : stringB.localeCompare(stringA);
      });
    };
    
    // Improved List Growth Chart component
    const ListGrowthChart = ({ data }) => {
      const chartRef = useRef(null);
      const chartInstance = useRef(null);
      
      useEffect(() => {
        if (!data || data.length === 0) return;
        
        const ctx = chartRef.current.getContext('2d');
        
        // Destroy existing chart
        if (chartInstance.current) {
          chartInstance.current.destroy();
        }
        
        // Prepare chart data
        const dates = data.map(item => formatDate(item.date));
        const totalMembers = data.map(item => Number(item.total_members));
        
        // Create a gradient background
        const gradientFill = ctx.createLinearGradient(0, 0, 0, 300);
        gradientFill.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
        gradientFill.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
        
        // Get data for last 7 days for clarity
        const last7Days = {
          dates: dates.slice(-7),
          totalMembers: totalMembers.slice(-7),
          membersAdded: data.slice(-7).map(item => Number(item.members_added)),
          membersRemoved: data.slice(-7).map(item => Number(item.members_removed))
        };
        
        // Create new chart - simplified to show total members prominently,
        // and added/removed as smaller annotations below
        chartInstance.current = new Chart(ctx, {
          type: 'line',
          data: {
            labels: dates,
            datasets: [
              {
                label: 'Total Subscribers',
                data: totalMembers,
                borderColor: 'rgba(255, 255, 255, 0.9)',
                backgroundColor: gradientFill,
                fill: true,
                tension: 0.3,
                borderWidth: 3,
                pointRadius: 4,
                pointBackgroundColor: 'white',
                pointHoverRadius: 6,
                pointHoverBackgroundColor: 'white',
                pointHoverBorderWidth: 2,
                pointHoverBorderColor: 'rgba(255, 255, 255, 0.5)'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  color: 'rgba(255, 255, 255, 0.8)',
                  font: {
                    size: 12,
                    weight: 'bold'
                  },
                  padding: 15
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(20, 19, 28, 0.9)',
                borderColor: 'rgba(255, 255, 255, 0.2)',
                borderWidth: 1,
                padding: 12,
                titleColor: 'rgba(255, 255, 255, 1)',
                bodyColor: 'rgba(255, 255, 255, 0.8)',
                bodyFont: {
                  size: 12
                },
                titleFont: {
                  size: 14,
                  weight: 'bold'
                },
                callbacks: {
                  afterTitle: (context) => {
                    const dataIndex = context[0].dataIndex;
                    const added = data[dataIndex].members_added;
                    const removed = data[dataIndex].members_removed;
                    return `\nAdded: +${added} | Removed: -${removed}`;
                  },
                  label: (context) => {
                    return ` Total Subscribers: ${formatNumber(context.raw)}`;
                  }
                }
              }
            },
            scales: {
              x: {
                grid: {
                  display: false
                },
                ticks: {
                  color: 'rgba(255, 255, 255, 0.7)',
                  maxRotation: 0,
                  autoSkip: true,
                  maxTicksLimit: 7
                }
              },
              y: {
                grid: {
                  color: 'rgba(255, 255, 255, 0.07)'
                },
                ticks: {
                  color: 'rgba(255, 255, 255, 0.7)',
                  padding: 10,
                  callback: function(value) {
                    return formatNumber(value);
                  }
                },
                beginAtZero: false
              }
            },
            interaction: {
              mode: 'nearest',
              axis: 'x',
              intersect: false
            }
          }
        });
        
        return () => {
          if (chartInstance.current) {
            chartInstance.current.destroy();
          }
        };
      }, [data]);
      
      return (
        <div>
          <div className="chart-container">
            <canvas ref={chartRef}></canvas>
          </div>
          
          {/* Daily change indicators below chart */}
          {data && data.length >= 7 && (
            <div className="grid grid-cols-1 md:grid-cols-7 gap-2 mt-4">
              {data.slice(-7).map((day, index) => (
                <div key={index} className="bg-opacity-10 bg-white rounded p-2 text-center">
                  <div className="text-xs text-gray-400">{formatDate(day.date)}</div>
                  <div className={`text-sm font-medium ${day.net_members_changed >= 0 ? 'positive-change' : 'negative-change'}`}>
                    {day.net_members_changed >= 0 ? '+' : ''}{day.net_members_changed}
                  </div>
                  <div className="flex justify-between text-xs mt-1">
                    <span className="positive-change">+{day.members_added}</span>
                    <span className="negative-change">-{day.members_removed}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    };
    
    // Campaign Table component - Updated to show percentages correctly and removed conversion rate
    const CampaignTable = ({ data }) => {
      const [sortField, setSortField] = useState('conversion_value');
      const [sortDirection, setSortDirection] = useState('desc');
      const [sortedData, setSortedData] = useState([]);
      
      useEffect(() => {
        if (!data || data.length === 0) {
          setSortedData([]);
          return;
        }
        
        const sorted = sortData(data, sortField, sortDirection);
        setSortedData(sorted);
      }, [data, sortField, sortDirection]);
      
      const handleSort = (field) => {
        if (field === sortField) {
          setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
          setSortField(field);
          setSortDirection('desc');
        }
      };
      
      const renderSortArrow = (field) => {
        if (sortField !== field) return null;
        return (
          <span className="ml-1">
            {sortDirection === 'asc' ? '↑' : '↓'}
          </span>
        );
      };
      
      return (
        <div className="overflow-x-auto">
          <table className="dashboard-table w-full">
            <thead>
              <tr className="text-white">
                <th onClick={() => handleSort('campaignname')}>
                  Campaign Name {renderSortArrow('campaignname')}
                </th>
                <th onClick={() => handleSort('send_time')}>
                  Send Date {renderSortArrow('send_time')}
                </th>
                <th onClick={() => handleSort('channel')}>
                  Channel {renderSortArrow('channel')}
                </th>
                <th onClick={() => handleSort('recipients')}>
                  Recipients {renderSortArrow('recipients')}
                </th>
                <th onClick={() => handleSort('open_rate')}>
                  Open Rate {renderSortArrow('open_rate')}
                </th>
                <th onClick={() => handleSort('click_rate')}>
                  Click Rate {renderSortArrow('click_rate')}
                </th>
                <th onClick={() => handleSort('revenue_per_recipient')}>
                  Rev/Recipient {renderSortArrow('revenue_per_recipient')}
                </th>
                <th onClick={() => handleSort('conversion_value')}>
                  Revenue {renderSortArrow('conversion_value')}
                </th>
              </tr>
            </thead>
            <tbody>
              {sortedData.length > 0 ? (
                sortedData.map((campaign, index) => (
                  <tr key={index} className="text-white">
                    <td className="font-medium">{campaign.campaignname}</td>
                    <td>{formatDate(campaign.send_time)}</td>
                    <td>
                      <span className="status-badge">
                        {campaign.channel}
                      </span>
                    </td>
                    <td>{formatNumber(campaign.recipients)}</td>
                    <td>{formatPercentage(campaign.open_rate)}</td>
                    <td>{formatPercentage(campaign.click_rate)}</td>
                    <td>{formatCurrency(campaign.revenue_per_recipient)}</td>
                    <td>{formatCurrency(campaign.conversion_value)}</td>
                  </tr>
                ))
              ) : (
                <tr>
                  <td colSpan="8" className="text-center text-gray-400 py-4">
                    No campaign data available
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      );
    };
    
    // Flow Table component - Updated to group by flow name
    const FlowTable = ({ data }) => {
      const [sortField, setSortField] = useState('conversion_value');
      const [sortDirection, setSortDirection] = useState('desc');
      const [groupedData, setGroupedData] = useState({});
      
      useEffect(() => {
        if (!data || data.length === 0) {
          setGroupedData({});
          return;
        }
        
        // Group by flow_name
        const grouped = _.groupBy(data, 'flow_name');
        
        // Sort flow groups by total conversion value
        const sortedGroups = {};
        const flowNames = Object.keys(grouped);
        
        // Sort flow names by total conversion value in each group
        const flowNamesSorted = flowNames.sort((a, b) => {
          const totalValueA = grouped[a].reduce((sum, item) => sum + (Number(item.conversion_value) || 0), 0);
          const totalValueB = grouped[b].reduce((sum, item) => sum + (Number(item.conversion_value) || 0), 0);
          return totalValueB - totalValueA;
        });
        
        // For each flow name, sort its emails by the sortField
        flowNamesSorted.forEach(flowName => {
          sortedGroups[flowName] = sortData(grouped[flowName], sortField, sortDirection);
        });
        
        setGroupedData(sortedGroups);
      }, [data, sortField, sortDirection]);
      
      const handleSort = (field) => {
        if (field === sortField) {
          setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
          setSortField(field);
          setSortDirection('desc');
        }
      };
      
      const renderSortArrow = (field) => {
        if (sortField !== field) return null;
        return (
          <span className="ml-1">
            {sortDirection === 'asc' ? '↑' : '↓'}
          </span>
        );
      };
      
      return (
        <div className="overflow-x-auto">
          <table className="dashboard-table w-full">
            <thead>
              <tr className="text-white">
                <th onClick={() => handleSort('email_name')}>
                  Email {renderSortArrow('email_name')}
                </th>
                <th onClick={() => handleSort('status')}>
                  Status {renderSortArrow('status')}
                </th>
                <th onClick={() => handleSort('recipients')}>
                  Recipients {renderSortArrow('recipients')}
                </th>
                <th onClick={() => handleSort('open_rate')}>
                  Open Rate {renderSortArrow('open_rate')}
                </th>
                <th onClick={() => handleSort('click_rate')}>
                  Click Rate {renderSortArrow('click_rate')}
                </th>
                <th onClick={() => handleSort('revenue_per_recipient')}>
                  Rev/Recipient {renderSortArrow('revenue_per_recipient')}
                </th>
                <th onClick={() => handleSort('conversion_value')}>
                  Revenue {renderSortArrow('conversion_value')}
                </th>
              </tr>
            </thead>
            <tbody>
              {Object.keys(groupedData).length > 0 ? (
                Object.entries(groupedData).map(([flowName, flows]) => (
                  <React.Fragment key={flowName}>
                    {/* Flow group header */}
                    <tr>
                      <td colSpan="7" className="flow-group-header">
                        {flowName}
                        <span className="text-sm ml-2 opacity-70">
                          ({flows.length} {flows.length === 1 ? 'email' : 'emails'})
                        </span>
                      </td>
                    </tr>
                    
                    {/* Flow emails in this group */}
                    {flows.map((flow, index) => (
                      <tr key={`${flowName}-${index}`} className="text-white">
                        <td className="pl-6 font-medium">{flow.email_name}</td>
                        <td>
                          <span className="status-badge">
                            {flow.status}
                          </span>
                        </td>
                        <td>{formatNumber(flow.recipients)}</td>
                        <td>{formatPercentage(flow.open_rate || 0)}</td>
                        <td>{formatPercentage(flow.click_rate)}</td>
                        <td>{formatCurrency(flow.revenue_per_recipient)}</td>
                        <td>{formatCurrency(flow.conversion_value)}</td>
                      </tr>
                    ))}
                  </React.Fragment>
                ))
              ) : (
                <tr>
                  <td colSpan="7" className="text-center text-gray-400 py-4">
                    No flow data available
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      );
    };
    
    // Revenue Metrics component - Changed from donut to horizontal bars
    const RevenueMetrics = ({ data }) => {
      // Check if there is SMS data
      const hasSmsData = () => {
        if (!data) return false;
        
        // Check if SMS revenue exists and is significant
        const smsRev = parseFloat(data.sms_rev) || 0;
        return smsRev > 0;
      };
      
      // Calculate revenue breakdown
      const calculateRevenueBreakdown = () => {
        if (!data) return [];
        
        const totalRev = parseFloat(data.total_rev) || 0;
        if (totalRev === 0) return [];
        
        const result = [];
        
        // Add campaign email revenue
        const campaignEmailRev = parseFloat(data.campaign_email_rev) || 0;
        if (campaignEmailRev > 0) {
          result.push({
            label: 'Campaign Email',
            value: campaignEmailRev,
            percentage: (campaignEmailRev / totalRev) * 100
          });
        }
        
        // Add flow email revenue
        const flowEmailRev = parseFloat(data.flow_email_rev) || 0;
        if (flowEmailRev > 0) {
          result.push({
            label: 'Flow Email',
            value: flowEmailRev,
            percentage: (flowEmailRev / totalRev) * 100
          });
        }
        
        // Only add SMS if it exists and is significant
        if (hasSmsData()) {
          // Add campaign SMS revenue
          const campaignSmsRev = parseFloat(data.campaign_sms_rev) || 0;
          if (campaignSmsRev > 0) {
            result.push({
              label: 'Campaign SMS',
              value: campaignSmsRev,
              percentage: (campaignSmsRev / totalRev) * 100
            });
          }
          
          // Add flow SMS revenue
          const flowSmsRev = parseFloat(data.flow_sms_rev) || 0;
          if (flowSmsRev > 0) {
            result.push({
              label: 'Flow SMS',
              value: flowSmsRev,
              percentage: (flowSmsRev / totalRev) * 100
            });
          }
        }
        
        return result.sort((a, b) => b.value - a.value);
      };
