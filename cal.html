<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Campaign Approval Calendar</title>
  <!-- Include React and ReactDOM -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <!-- Include Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Include Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Include Lodash -->
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <style>
    body {
      background-color: #0a0b18;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .campaign-email {
      background-color: #6b46c1;
    }
    .campaign-sms {
      background-color: #d69e2e;
    }
  </style>
</head>
<body class="bg-gray-900">
  <div id="root" class="min-h-screen py-8"></div>

  <script type="text/babel">
    // Import React hooks
    const { useState, useEffect } = React;
    
    const CampaignCalendar = () => {
      const [campaigns, setCampaigns] = useState([]);
      const [selectedCampaign, setSelectedCampaign] = useState(null);
      const [feedback, setFeedback] = useState('');
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [currentMonth, setCurrentMonth] = useState(new Date());
      const [selectedDate, setSelectedDate] = useState(null);
      const [updateStatus, setUpdateStatus] = useState(null);
      const [debug, setDebug] = useState('No data fetched yet');

      // Your webhook URLs - adjust as needed
      const fetchCampaignsUrl = 'https://hook.us2.make.com/dlcqdia9qozi8lca39jytiu27xrf1t1l';
      const updateCampaignUrl = 'https://hook.us2.make.com/wem64vvx9irk7tys6itjpyt27bqorbvg';

      // This is the simplified method to handle a simple text response
      // from your webhook that contains the minimal campaign information
      const processCampaignData = (responseText) => {
        try {
          // Try to parse as JSON first
          try {
            const jsonData = JSON.parse(responseText);
            
            // If it's a valid JSON object or array, process it accordingly
            if (Array.isArray(jsonData)) {
              // It's an array of campaigns
              return jsonData.map(formatCampaign);
            } else if (jsonData && typeof jsonData === 'object') {
              // It's a single campaign object
              return [formatCampaign(jsonData)];
            }
          } catch (e) {
            // Not valid JSON, continue with text processing
            console.log("Not valid JSON:", e);
          }
          
          // If the above didn't work, try to extract data from text
          // This is a very simple, flexible parser for key-value data
          const lines = responseText.split('\n');
          const campaignData = {};
          
          // Look for standard keys in the text
          for (const line of lines) {
            if (line.includes(':')) {
              const [key, value] = line.split(':', 2).map(s => s.trim());
              campaignData[key] = value;
            }
          }
          
          // If we found some useful data, format it
          if (campaignData.id || campaignData.Tasks || campaignData.title) {
            return [formatCampaign(campaignData)];
          }
          
          // If all else fails, create a single dummy campaign from the text
          return [{
            id: 'text-1',
            title: responseText.slice(0, 30) + '...',
            type: 'email',
            start: new Date(),
            end: new Date(),
            description: responseText,
            status: 'Unknown',
            clientId: 'Unknown',
            feedback: ''
          }];
          
        } catch (error) {
          console.error('Error processing campaign data:', error);
          setDebug(`Error processing data: ${error.message}`);
          return [];
        }
      };
      
      // Helper function to format a campaign object consistently
      const formatCampaign = (data) => {
        // Handle different possible structures
        const fields = data.fields || data;
        const id = data.id || data.recordId || "unknown";
        
        // Extract values with fallbacks for different field naming formats
        const getField = (possibleNames, defaultValue = '') => {
          for (const name of possibleNames) {
            if (fields[name] !== undefined) return fields[name];
          }
          return defaultValue;
        };
        
        const title = getField(['Tasks', 'tasks', 'Task', 'task', 'Name', 'name', 'Title', 'title']);
        const date = getField(['Send Date', 'send_date', 'Date', 'date', 'scheduled_date']);
        const status = getField(['Stage', 'stage', 'Status', 'status']);
        const client = getField(['CLIENT', 'Client', 'client', 'Customer', 'customer']);
        const notes = getField(['Notes', 'notes', 'Description', 'description']);
        
        // Create a standardized campaign object
        return {
          id: id,
          title: title || 'Untitled Campaign',
          type: determineCampaignType(title),
          start: new Date(date || new Date()),
          end: new Date(date || new Date()),
          description: notes || '',
          status: status || 'pending',
          clientId: client || '',
          feedback: notes || ''
        };
      };

      useEffect(() => {
        fetchCampaigns();
      }, []);

      const fetchCampaigns = async () => {
        try {
          setLoading(true);
          setDebug('Fetching campaigns...');
          
          const response = await fetch(fetchCampaignsUrl);
          
          if (!response.ok) {
            setDebug(`Response not OK: ${response.status}`);
            throw new Error(`Failed to fetch campaigns: ${response.status}`);
          }
          
          const text = await response.text();
          setDebug(`Raw response (first 200 chars): ${text.substring(0, 200)}`);
          
          // Process the response text in a flexible way
          const formattedCampaigns = processCampaignData(text);
          
          setDebug(`Processed ${formattedCampaigns.length} campaigns`);
          setCampaigns(formattedCampaigns);
        } catch (error) {
          console.error('Error fetching campaigns:', error);
          setDebug(`Error: ${error.message}`);
          setError(error.message);
          // If fetching fails, set an empty array
          setCampaigns([]);
        } finally {
          setLoading(false);
        }
      };

      // Helper function to determine campaign type based on name
      const determineCampaignType = (name) => {
        if (!name) return 'email'; // Default
        
        const lowerName = name.toLowerCase();
        if (lowerName.includes('sms') || lowerName.includes('text')) {
          return 'sms';
        }
        return 'email';
      };

      const handleSelectCampaign = (campaign) => {
        setSelectedCampaign(campaign);
        setFeedback(campaign.feedback || '');
        setUpdateStatus(null);
      };

      const handleApproval = async (approved) => {
        try {
          setUpdateStatus({ loading: true, error: null });
          const response = await fetch(updateCampaignUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              campaignId: selectedCampaign.id,
              approved: approved,
              feedback: feedback
            })
          });
          
          if (!response.ok) throw new Error('Failed to update campaign status');
          
          // Update local state
          setCampaigns(campaigns.map(campaign => 
            campaign.id === selectedCampaign.id 
              ? { 
                  ...campaign, 
                  status: approved ? 'Approved' : 'Needs Revision', 
                  feedback 
                } 
              : campaign
          ));
          
          setUpdateStatus({ 
            loading: false, 
            success: true, 
            message: `Campaign ${approved ? 'approved' : 'sent for revision'} successfully!` 
          });
          
          // Clear selected campaign after a delay to show success message
          setTimeout(() => {
            setSelectedCampaign(null);
            setFeedback('');
            setUpdateStatus(null);
          }, 2000);
          
        } catch (error) {
          console.error('Error updating approval status:', error);
          setUpdateStatus({ 
            loading: false, 
            error: true, 
            message: error.message || 'Error updating campaign status' 
          });
        }
      };

      const getCampaignTypeClass = (type) => {
        return type === 'sms' ? 'campaign-sms' : 'campaign-email';
      };

      // Calendar navigation
      const prevMonth = () => {
        setCurrentMonth(new Date(currentMonth.getFullYear(), currentMonth.getMonth() - 1, 1));
      };

      const nextMonth = () => {
        setCurrentMonth(new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 1));
      };

      // Generate calendar days
      const getDaysInMonth = (date) => {
        const year = date.getFullYear();
        const month = date.getMonth();
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        
        // Get day of week of first day (0 = Sunday)
        const firstDayOfWeek = firstDay.getDay();
        
        // Array for all days to display
        const days = [];
        
        // Add empty slots for days before first of month
        for (let i = 0; i < firstDayOfWeek; i++) {
          days.push({ date: null, isCurrentMonth: false });
        }
        
        // Add all days in month
        for (let i = 1; i <= lastDay.getDate(); i++) {
          days.push({ 
            date: new Date(year, month, i),
            isCurrentMonth: true 
          });
        }
        
        return days;
      };

      const days = getDaysInMonth(currentMonth);
      
      // Group campaigns by date for calendar display
      const campaignsByDate = _.groupBy(campaigns, campaign => 
        campaign.start.toDateString()
      );

      // Get day name headers
      const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

      // Format date for display
      const formatDate = (date) => {
        if (!date) return '';
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric',
          year: 'numeric'
        });
      };

      return (
        <div className="container mx-auto p-4">
          <div className="bg-gray-900 rounded-lg shadow-lg overflow-hidden">
            <div className="p-6 bg-black text-white">
              <h1 className="text-2xl font-bold text-center">CONTENT CALENDAR</h1>
            </div>
            
            {error && (
              <div className="p-4 bg-red-800 text-white">
                <p className="font-bold">Error:</p>
                <p>{error}</p>
              </div>
            )}
            
            {loading && (
              <div className="flex justify-center items-center py-4 bg-gray-900 text-white">
                <p>Loading campaigns...</p>
              </div>
            )}
            
            {/* Display debug info (remove in production) */}
            <div className="p-4 bg-gray-800 text-white text-sm border-b border-gray-700">
              <p className="font-bold">Debug:</p>
              <p className="mb-2">{debug}</p>
              <p>Total Campaigns: {campaigns.length}</p>
              {campaigns.length > 0 && (
                <div className="mt-2">
                  <p>First Campaign:</p>
                  <pre className="text-xs overflow-auto max-h-40 bg-gray-900 p-2">{JSON.stringify(campaigns[0], null, 2)}</pre>
                </div>
              )}
              <button 
                onClick={fetchCampaigns}
                className="mt-2 px-3 py-1 bg-blue-600 rounded hover:bg-blue-500"
              >
                Refresh Data
              </button>
            </div>
            
            <div className="p-6 bg-gray-900">
              <div className="flex justify-between items-center mb-4 text-white">
                <button onClick={prevMonth} className="px-4 py-2 bg-gray-800 rounded hover:bg-gray-700">
                  &lt; Previous
                </button>
                <h2 className="text-xl font-semibold">
                  {currentMonth.toLocaleString('default', { month: 'long', year: 'numeric' })}
                </h2>
                <div className="flex space-x-2">
                  <button onClick={nextMonth} className="px-4 py-2 bg-gray-800 rounded hover:bg-gray-700">
                    Next &gt;
                  </button>
                  <button className="px-4 py-2 bg-green-600 rounded hover:bg-green-500">
                    + Add
                  </button>
                </div>
              </div>
              
              {/* Calendar grid */}
              <div className="grid grid-cols-7 gap-1 rounded-lg overflow-hidden">
                {/* Weekday headers */}
                {weekdays.map(day => (
                  <div key={day} className="p-2 bg-gray-800 text-center font-semibold text-white">
                    {day}
                  </div>
                ))}
                
                {/* Calendar days */}
                {days.map((day, index) => {
                  // Get campaigns for this day
                  const dayCampaigns = day.date ? 
                    (campaignsByDate[day.date.toDateString()] || []) : [];
                  
                  return (
                    <div 
                      key={index}
                      className={`min-h-28 p-1 ${
                        day.isCurrentMonth ? 'bg-gray-900 border border-gray-800' : 'bg-black'
                      } ${
                        selectedDate && day.date && selectedDate.toDateString() === day.date.toDateString() 
                          ? 'ring-1 ring-gray-600' 
                          : ''
                      } text-white`}
                      onClick={() => day.date && setSelectedDate(day.date)}
                    >
                      {day.date && (
                        <>
                          <div className="text-right text-sm p-1">
                            {day.date.getDate()}
                          </div>
                          <div className="mt-1">
                            {dayCampaigns.map(campaign => (
                              <div 
                                key={campaign.id}
                                className={`mb-1 py-1 px-2 text-xs text-white rounded cursor-pointer truncate ${getCampaignTypeClass(campaign.type)}`}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleSelectCampaign(campaign);
                                }}
                              >
                                {campaign.title}
                              </div>
                            ))}
                          </div>
                        </>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
          
          {selectedCampaign && (
            <div className="mt-4 bg-gray-900 text-white rounded-lg shadow-lg p-4">
              <h2 className="text-xl font-semibold mb-2">{selectedCampaign.title}</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                  <p className="mb-2">
                    <span className="font-semibold">Date:</span> {formatDate(selectedCampaign.start)}
                  </p>
                  <p className="mb-2">
                    <span className="font-semibold">Status:</span> 
                    <span className="ml-2 px-2 py-1 rounded text-white bg-gray-700">
                      {selectedCampaign.status}
                    </span>
                  </p>
                </div>
                <div>
                  <p className="mb-2">
                    <span className="font-semibold">Type:</span> 
                    <span className={`ml-2 px-2 py-1 rounded text-white ${getCampaignTypeClass(selectedCampaign.type)}`}>
                      {selectedCampaign.type === 'sms' ? 'SMS' : 'Email'}
                    </span>
                  </p>
                  <p className="mb-2">
                    <span className="font-semibold">Client:</span> {selectedCampaign.clientId}
                  </p>
                </div>
              </div>
              
              {selectedCampaign.description && (
                <div className="mb-4 p-3 bg-gray-800 border border-gray-700 rounded">
                  <p className="font-semibold text-sm text-white mb-1">Campaign Details:</p>
                  <p className="text-sm">{selectedCampaign.description}</p>
                </div>
              )}
                  
              {updateStatus?.loading ? (
                <div className="flex justify-center py-2">
                  <p>Updating campaign...</p>
                </div>
              ) : updateStatus?.success ? (
                <div className="bg-green-900 border border-green-700 text-green-200 px-4 py-2 rounded mb-4">
                  {updateStatus.message}
                </div>
              ) : updateStatus?.error ? (
                <div className="bg-red-900 border border-red-700 text-red-200 px-4 py-2 rounded mb-4">
                  {updateStatus.message}
                </div>
              ) : (
                <div className="space-y-4">
                  <div className="border-t border-gray-700 pt-4">
                    <label className="block font-semibold mb-2">Client Notes:</label>
                    <textarea
                      className="w-full p-2 rounded bg-gray-800 border border-gray-700 text-white"
                      rows={4}
                      value={feedback}
                      onChange={(e) => setFeedback(e.target.value)}
                      placeholder="Enter your feedback or revision requests here..."
                      disabled={updateStatus?.loading}
                    />
                  </div>
                  
                  <div className="grid grid-cols-2 gap-4">
                    <button
                      onClick={() => handleApproval(true)}
                      className="py-2 bg-green-700 text-white rounded hover:bg-green-600"
                    >
                      Approve
                    </button>
                    <button
                      onClick={() => handleApproval(false)}
                      className="py-2 bg-yellow-700 text-white rounded hover:bg-yellow-600"
                    >
                      Revise
                    </button>
                  </div>
                  
                  <button
                    onClick={() => {
                      setSelectedCampaign(null);
                      setFeedback('');
                    }}
                    className="w-full py-2 bg-gray-700 text-white rounded hover:bg-gray-600"
                  >
                    Cancel
                  </button>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Render the app
    ReactDOM.render(
      <CampaignCalendar />,
      document.getElementById('root')
    );
  </script>
</body>
</html>
