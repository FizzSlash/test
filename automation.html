<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customer Journey Mapping</title>
  <!-- Include React and ReactDOM -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <!-- Include Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Include Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: rgba(20, 19, 28, 0.7);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    /* Container styling with transparent white stroke */
    .journey-container {
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);
      background-color: rgba(20, 19, 28, 0.3);
      backdrop-filter: blur(10px);
      border-radius: 8px;
      overflow: hidden;
    }
    
    /* Node styling */
    .automation-node {
      border: 1px solid rgba(255, 255, 255, 0.3);
      background-color: rgba(36, 35, 49, 0.7);
      border-radius: 6px;
      padding: 10px;
      color: white;
      width: 180px;
      margin: 10px;
      transition: all 0.2s ease;
      backdrop-filter: blur(5px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      position: absolute;
      cursor: move;
    }
    
    .automation-node:hover {
      border-color: rgba(255, 255, 255, 0.6);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .automation-node.email {
      border-left: 4px solid rgba(136, 84, 208, 0.8);
    }
    
    .automation-node.trigger {
      border-left: 4px solid rgba(56, 189, 248, 0.8);
    }
    
    .automation-node.action {
      border-left: 4px solid rgba(234, 179, 8, 0.8);
    }
    
    .automation-node.filter {
      border-left: 4px solid rgba(239, 68, 68, 0.8);
    }
    
    /* Canvas styling */
    .canvas-area {
      background-color: rgba(17, 24, 39, 0.2);
      background-image: 
        linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
      width: 100%;
      height: 600px;
      position: relative;
      overflow: hidden;
    }
    
    /* Header styling for consistency */
    .header-container {
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background-color: rgba(0, 0, 0, 0.2);
    }
    
    /* Toolbox styling */
    .toolbox {
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      background-color: rgba(0, 0, 0, 0.2);
    }
    
    .tool-item {
      border: 1px solid rgba(255, 255, 255, 0.1);
      background-color: rgba(36, 35, 49, 0.5);
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .tool-item:hover {
      border-color: rgba(255, 255, 255, 0.3);
      background-color: rgba(36, 35, 49, 0.7);
    }
    
    /* Controls styling */
    .control-button {
      background-color: transparent;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .control-button:hover {
      background-color: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }
    
    /* Save notification */
    .save-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: rgba(16, 185, 129, 0.2);
      border: 1px solid rgba(16, 185, 129, 0.5);
      color: #d1fae5;
      padding: 12px 20px;
      border-radius: 4px;
      backdrop-filter: blur(5px);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      transform: translateY(0);
      opacity: 1;
    }
    
    .save-notification.hidden {
      transform: translateY(20px);
      opacity: 0;
    }
    
    /* Node details panel */
    .node-details {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 300px;
      background-color: rgba(36, 35, 49, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 16px;
      color: white;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 50;
      transition: all 0.3s ease;
    }
    
    .node-details.hidden {
      transform: translateX(320px);
      opacity: 0;
      pointer-events: none;
    }
    
    .detail-field {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      padding: 8px;
      width: 100%;
      color: white;
    }
    
    .detail-field:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.4);
    }
    
    .connection-line {
      position: absolute;
      height: 2px;
      background-color: rgba(255, 255, 255, 0.4);
      transform-origin: 0 0;
      pointer-events: none;
    }
  </style>
</head>
<body class="bg-transparent">
  <div id="root" class="min-h-screen py-8"></div>

  <script type="text/babel">
    // Import React hooks
    const { useState, useEffect, useRef } = React;
    
    const CustomerJourney = () => {
      const [nodes, setNodes] = useState([]);
      const [connections, setConnections] = useState([]);
      const [selectedNode, setSelectedNode] = useState(null);
      const [showDetails, setShowDetails] = useState(false);
      const [saveNotification, setSaveNotification] = useState(false);
      const [journeyName, setJourneyName] = useState('New Customer Journey');
      const [isDragging, setIsDragging] = useState(false);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
      
      const canvasRef = useRef(null);
      
      // Load saved journeys on mount
      useEffect(() => {
        const savedJourney = localStorage.getItem('customerJourney');
        if (savedJourney) {
          try {
            const { nodes: savedNodes, connections: savedConnections, name } = JSON.parse(savedJourney);
            if (savedNodes) {
              setNodes(savedNodes);
            }
            if (savedConnections) {
              setConnections(savedConnections);
            }
            if (name) {
              setJourneyName(name);
            }
          } catch (e) {
            console.error('Failed to load saved journey:', e);
          }
        }
      }, []);
      
      // Save journey
      const saveJourney = () => {
        const journeyData = {
          nodes,
          connections,
          name: journeyName
        };
        
        localStorage.setItem('customerJourney', JSON.stringify(journeyData));
        
        // Show notification
        setSaveNotification(true);
        setTimeout(() => setSaveNotification(false), 3000);
      };
      
      // Clear canvas
      const clearCanvas = () => {
        if (window.confirm('Are you sure you want to clear the canvas? This action cannot be undone.')) {
          setNodes([]);
          setConnections([]);
          setSelectedNode(null);
          setShowDetails(false);
        }
      };
      
      // Export journey
      const exportJourney = () => {
        const journeyData = {
          nodes,
          connections,
          name: journeyName
        };
        
        const jsonString = JSON.stringify(journeyData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `${journeyName.replace(/\s+/g, '-').toLowerCase()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };
      
      // Import journey
      const importJourney = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const journeyData = JSON.parse(e.target.result);
              if (journeyData.nodes) {
                setNodes(journeyData.nodes);
              }
              if (journeyData.connections) {
                setConnections(journeyData.connections);
              }
              if (journeyData.name) {
                setJourneyName(journeyData.name);
              }
              
              // Show notification
              setSaveNotification(true);
              setTimeout(() => setSaveNotification(false), 3000);
            } catch (error) {
              console.error('Failed to import journey:', error);
            }
          };
          reader.readAsText(file);
        }
      };
      
      // Add a new node from toolbox
      const addNode = (type, label, description) => {
        const canvasRect = canvasRef.current.getBoundingClientRect();
        const newNode = {
          id: `node-${Date.now()}`,
          type,
          label,
          description,
          x: canvasRect.width / 2 - 90 + Math.random() * 100,
          y: canvasRect.height / 2 - 50 + Math.random() * 100
        };
        
        setNodes([...nodes, newNode]);
      };
      
      // Handle node click
      const handleNodeClick = (node, e) => {
        e.stopPropagation();
        setSelectedNode(node);
        setShowDetails(true);
      };
      
      // Start dragging a node
      const startDrag = (node, e) => {
        e.stopPropagation();
        if (e.button !== 0) return; // Only left mouse button
        
        setIsDragging(true);
        setSelectedNode(node);
        
        const nodeEl = e.currentTarget;
        const nodeRect = nodeEl.getBoundingClientRect();
        
        setDragOffset({
          x: e.clientX - nodeRect.left,
          y: e.clientY - nodeRect.top
        });
        
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
      };
      
      // Handle node dragging
      const handleDrag = (e) => {
        if (!isDragging || !selectedNode) return;
        
        const canvasRect = canvasRef.current.getBoundingClientRect();
        
        const newX = e.clientX - canvasRect.left - dragOffset.x;
        const newY = e.clientY - canvasRect.top - dragOffset.y;
        
        setNodes(nodes.map(node => 
          node.id === selectedNode.id
            ? { ...node, x: newX, y: newY }
            : node
        ));
      };
      
      // Stop dragging
      const stopDrag = () => {
        setIsDragging(false);
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
      };
      
      // Update node details
      const updateSelectedNode = (field, value) => {
        if (!selectedNode) return;
        
        setNodes(nodes.map(node => 
          node.id === selectedNode.id
            ? { ...node, [field]: value }
            : node
        ));
        
        // Update the selected node as well
        setSelectedNode(prev => ({ ...prev, [field]: value }));
      };
      
      // Delete a node
      const deleteNode = (nodeId) => {
        setNodes(nodes.filter(node => node.id !== nodeId));
        setConnections(connections.filter(conn => 
          conn.source !== nodeId && conn.target !== nodeId
        ));
        setShowDetails(false);
        setSelectedNode(null);
      };
      
      // Create a connection between nodes
      const createConnection = (sourceId, targetId) => {
        // Check if connection already exists
        const connectionExists = connections.some(conn => 
          conn.source === sourceId && conn.target === targetId
        );
        
        if (connectionExists) return;
        
        // Add new connection
        setConnections([...connections, { source: sourceId, target: targetId }]);
      };
      
      // Handle canvas click to deselect nodes
      const handleCanvasClick = () => {
        setSelectedNode(null);
        setShowDetails(false);
      };
      
      // Connect two selected nodes
      const connectNodes = () => {
        if (!selectedNode) return;
        
        // Start connection mode
        const startConnection = (e) => {
          e.stopPropagation();
          const targetNode = nodes.find(node => node.id === e.currentTarget.dataset.nodeId);
          
          if (targetNode && targetNode.id !== selectedNode.id) {
            createConnection(selectedNode.id, targetNode.id);
          }
          
          // Exit connection mode
          document.querySelectorAll('.automation-node').forEach(el => {
            el.removeEventListener('click', startConnection);
            el.classList.remove('connect-mode');
          });
        };
        
        // Mark all nodes as connection targets
        document.querySelectorAll('.automation-node').forEach(el => {
          if (el.dataset.nodeId !== selectedNode.id) {
            el.addEventListener('click', startConnection);
            el.classList.add('connect-mode');
          }
        });
      };
      
      // Calculate connection lines between nodes
      const renderConnections = () => {
        return connections.map((conn, index) => {
          const sourceNode = nodes.find(node => node.id === conn.source);
          const targetNode = nodes.find(node => node.id === conn.target);
          
          if (!sourceNode || !targetNode) return null;
          
          // Calculate source and target positions
          const sourceX = sourceNode.x + 90; // Center of node width
          const sourceY = sourceNode.y + 20; // Near top of node
          const targetX = targetNode.x + 90;
          const targetY = targetNode.y;
          
          // Calculate angle and length
          const dx = targetX - sourceX;
          const dy = targetY - sourceY;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * (180 / Math.PI);
          
          return (
            <div 
              key={`conn-${index}`}
              className="connection-line"
              style={{
                width: `${length}px`,
                left: `${sourceX}px`,
                top: `${sourceY}px`,
                transform: `rotate(${angle}deg)`,
              }}
            ></div>
          );
        });
      };
      
      // Automation step types
      const automationTypes = [
        { type: 'trigger', label: 'Trigger', description: 'Starts the automation' },
        { type: 'email', label: 'Send Email', description: 'Sends an email to contact' },
        { type: 'action', label: 'Action', description: 'Performs an action' },
        { type: 'filter', label: 'Filter', description: 'Conditional logic' },
        { type: 'email', label: 'Email Sequence', description: 'Sends multiple emails' },
        { type: 'action', label: 'Update CRM', description: 'Updates customer record' },
        { type: 'action', label: 'Send SMS', description: 'Sends text message' },
        { type: 'filter', label: 'Delay', description: 'Wait for time period' },
      ];
      
      return (
        <div className="container mx-auto p-4">
          <div className="journey-container">
            <div className="p-6 bg-transparent text-white header-container">
              <div className="flex justify-between items-center">
                <div className="flex items-center">
                  <h1 className="text-2xl font-bold">CUSTOMER JOURNEY</h1>
                  <input
                    type="text"
                    value={journeyName}
                    onChange={(e) => setJourneyName(e.target.value)}
                    className="ml-4 bg-transparent border-b border-white px-2 py-1"
                  />
                </div>
                <div className="flex space-x-2">
                  <button className="control-button" onClick={saveJourney}>
                    Save
                  </button>
                  <button className="control-button" onClick={exportJourney}>
                    Export
                  </button>
                  <label className="control-button cursor-pointer">
                    Import
                    <input
                      type="file"
                      accept=".json"
                      className="hidden"
                      onChange={importJourney}
                    />
                  </label>
                  <button className="control-button" onClick={clearCanvas}>
                    Clear
                  </button>
                </div>
              </div>
            </div>
            
            <div className="flex">
              {/* Toolbox sidebar */}
              <div className="w-48 p-4 bg-gray-900 bg-opacity-30 toolbox">
                <h2 className="text-white font-bold mb-3">Automation Steps</h2>
                <div className="space-y-2">
                  {automationTypes.map((item, index) => (
                    <div
                      key={index}
                      className={`tool-item p-2 ${item.type}`}
                      onClick={() => addNode(item.type, item.label, item.description)}
                    >
                      <div className="text-sm font-medium text-white">{item.label}</div>
                      <div className="text-xs text-gray-300">{item.description}</div>
                    </div>
                  ))}
                </div>
              </div>
              
              {/* Canvas area */}
              <div 
                className="flex-grow canvas-area" 
                ref={canvasRef}
                onClick={handleCanvasClick}
              >
                {/* Connection lines */}
                {renderConnections()}
                
                {/* Automation nodes */}
                {nodes.map(node => (
                  <div
                    key={node.id}
                    data-node-id={node.id}
                    className={`automation-node ${node.type}`}
                    style={{ left: `${node.x}px`, top: `${node.y}px` }}
                    onClick={(e) => handleNodeClick(node, e)}
                    onMouseDown={(e) => startDrag(node, e)}
                  >
                    <div className="font-semibold">{node.label}</div>
                    <div className="text-xs text-gray-300 mt-1">{node.description}</div>
                  </div>
                ))}
              </div>
            </div>
          </div>
          
          {/* Node details panel */}
          <div className={`node-details ${showDetails ? '' : 'hidden'}`}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-semibold">Node Details</h3>
              <button 
                className="text-white opacity-70 hover:opacity-100"
                onClick={() => setShowDetails(false)}
              >
                Ã—
              </button>
            </div>
            
            {selectedNode && (
              <div className="space-y-4">
                <div>
                  <label className="block text-sm mb-1">Label</label>
                  <input
                    type="text"
                    value={selectedNode.label}
                    onChange={(e) => updateSelectedNode('label', e.target.value)}
                    className="detail-field"
                  />
                </div>
                
                <div>
                  <label className="block text-sm mb-1">Description</label>
                  <input
                    type="text"
                    value={selectedNode.description}
                    onChange={(e) => updateSelectedNode('description', e.target.value)}
                    className="detail-field"
                  />
                </div>
                
                <div>
                  <label className="block text-sm mb-1">Type</label>
                  <select
                    value={selectedNode.type}
                    onChange={(e) => updateSelectedNode('type', e.target.value)}
                    className="detail-field"
                  >
                    <option value="trigger">Trigger</option>
                    <option value="email">Email</option>
                    <option value="action">Action</option>
                    <option value="filter">Filter</option>
                  </select>
                </div>
                
                <div className="pt-4 space-y-2">
                  <button
                    className="w-full py-2 bg-transparent border border-white text-white rounded hover:bg-white hover:bg-opacity-10"
                    onClick={connectNodes}
                  >
                    Connect to Another Node
                  </button>
                  
                  <button
                    className="w-full py-2 bg-transparent border border-red-400 text-red-400 rounded hover:bg-red-400 hover:bg-opacity-10"
                    onClick={() => deleteNode(selectedNode.id)}
                  >
                    Delete Node
                  </button>
                </div>
              </div>
            )}
          </div>
          
          {/* Save notification */}
          <div className={`save-notification ${saveNotification ? '' : 'hidden'}`}>
            Journey saved successfully!
          </div>
        </div>
      );
    };
    
    // Render the app
    ReactDOM.render(
      <CustomerJourney />,
      document.getElementById('root')
    );
  </script>
</body>
</html>
